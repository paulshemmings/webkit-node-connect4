var Game = {
	
	extensions : require('extensions.js'),
	Player : require('player.js'),
	board : null,
	view : null,
	REQUIRED_PLAYERS : 2,
	players : [],
	currentPlayerIndex : 0,

	GameStatusEnum : { 
		INITIALIZED : { value : 0, name : "INITIALIZED" },
		RUNNING : { value : 1, name : "RUNNING" },
		OVER : { value : 2, name : "OVER" },
		CLEAN : { value : 3, name : "CLEAN" }
	},
	gameStatus : null,

	LoggingLevelEnum : {
		INFO : { value : 0, name : "INFORMATION" },
		DEBUG : { value : 1, name : "DEBUG" }
	},
	loggingLevel : null,

	initialize : function(b, v) {
		this.board = b;
		this.view = v;
		this.view.drawBoard(this.board.getGrid());
		this.gameStatus = this.GameStatusEnum.INITIALIZED;
		this.loggingLevel = this.LoggingLevelEnum.INFO;
		return this;
	},

	start : function() {

		if (this.players.length < this.REQUIRED_PLAYERS) {
			return;
		}

		if (this.gameStatus != this.GameStatusEnum.INITIALIZED) {
			return;
		}

		this.writeStatus("Start game", true, this.LoggingLevelEnum.INFO);
		this.gameStatus = this.GameStatusEnum.RUNNING;		
		this.takeTurn();
	},

	reset : function() {
		this.board.reset();
		this.view.drawBoard(this.board.getGrid());

		this.players.length = 0;
		this.currentPlayerIndex = 0;
		this.view.drawPlayerList(this.players, this.currentPlayerIndex);
		this.writeStatus('', true, this.LoggingLevelEnum.INFO);

		this.gameStatus = this.GameStatusEnum.INITIALIZED;
	},

	takeTurn : function() {

		// show player has turn
		this.view.drawPlayerList(this.players, this.currentPlayerIndex);
		
		// if that player is an AI, take the turn for it
		if (this.players[this.currentPlayerIndex].isAI()) {

			// calculate the move for the player
			var move = this.calculateMove();

			// make the move for the player
			this.playMove(move.x, move.y);				
		}
	},

	calculateMove : function() {

		var grid = this.board.getGrid();
		var bestMove = { x : -1, y : -1, weight: -1 };		
		var opponent = (this.players.length-1) - this.currentPlayerIndex;

		var defensive = this.players[this.currentPlayerIndex].getBehaviorWeightings().defensive;
		var offensive = this.players[this.currentPlayerIndex].getBehaviorWeightings().offensive;

		for (var x=0; x<grid.rows.length; x++) {			

			if (!this.isMoveValid(x)) {
				continue;
			}

			var y = grid.rows[x].columns.length;

			// calculate weight for that position
			var playWeight = this.weighMove(this.currentPlayerIndex, x, y) * offensive;
			var blockWeight = this.weighMove(opponent, x, y) * defensive;
			
			// add weight to stop 4 in row
			if (playWeight == 3) {
				playWeight += playWeight;
			} 
						
			// add weight to complete 4 in row					
			if (blockWeight == 3) {
				blockWeight += blockWeight;
			}

			// check the next space up 
			// don't want to go here if next one up will give you 4, or them 4.
			playWeight -= this.weighMove(this.currentPlayerIndex, x, y-1) * (offensive * 0.8);
			blockWeight -= this.weighMove(opponent, x, y-1) * (defensive * 0.8);

			// combine weights 
			if( (playWeight+blockWeight) > bestMove.weight )
			{
				bestMove.x = x;
				bestMove.y = y;
				bestMove.weight = (playWeight+blockWeight);
			}
		}	
		return bestMove;
	},

	isMoveValid : function(x, y) {
		return this.board.rowHasSpace(x); 
	},

	playMove : function(x, y) {

		// are we running?
		if (this.gameStatus != this.GameStatusEnum.RUNNING) {
			return;
		}

		// check move is valid
		if (!this.isMoveValid(x, y)) {
			return;
		}

		this.writeStatus('move made [' + x + '][' + y + '] for player ' + this.currentPlayerIndex, false, this.LoggingLevelEnum.DEBUG);

		// add piece to board
		this.board.addPiece(this.currentPlayerIndex, x, y);

		// refresh the board
		var self = this;
		this.view.animateMove(this.board.getGrid(), this.currentPlayerIndex, x, function() {

			// check if that was the winning move
			var gameOver = self.isGameOver();
			if (gameOver) {
				self.gameStatus = self.GameStatusEnum.OVER;
				self.writeStatus('Game over', false, self.LoggingLevelEnum.INFO);
				self.writeStatus(self.players[self.currentPlayerIndex].getId() + ' wins', false, self.LoggingLevelEnum.INFO);
				return;
			}

			// move to next player
			self.currentPlayerIndex ++;
			if (self.currentPlayerIndex == self.players.length) {
				self.currentPlayerIndex = 0;
			} 

			// take next turn if game not over
			self.takeTurn();

		});
	},

	maxOf : function(first,second)
	{
		return first > second ? first : second;
	},	

	weighMove : function(player, x, y) {

		var playWeight = 
				this.board.countMatchingPieces(player, x, y, -1, 0) + 
				this.board.countMatchingPieces(player, x, y, 1, 0);

		playWeight = this.maxOf( playWeight, this.board.countMatchingPieces(player, x, y, 0, -1) + this.board.countMatchingPieces(player, x, y, 0, 1) );
		playWeight = this.maxOf( playWeight, this.board.countMatchingPieces(player, x, y, -1, -1) + this.board.countMatchingPieces(player, x, y, 1, 1) );
		playWeight = this.maxOf( playWeight, this.board.countMatchingPieces(player, x, y, 1, -1) + this.board.countMatchingPieces(player, x, y, -1, 1) );

		return playWeight;
	},	

	isGameOver : function() {
		var grid = this.board.getGrid();
		for (var x=0; x < grid.rows.length; x++) {
			for (var y=0; y < grid.rows[x].columns.length; y++) {			
				var playerIndex = grid.rows[x].columns[y];
				if(playerIndex != null) {			

					this.writeStatus('testing ' + playerIndex + ';' + x + ':' + y, false, this.LoggingLevelEnum.DEBUG);

					if( this.board.countMatchingPieces(playerIndex, x, y, -1, 0) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, 1, 0) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, 0, -1) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, 0, 1) > 2 ) return true;
					
					if( this.board.countMatchingPieces(playerIndex, x, y, -1, -1) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, 1, 1) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, 1, -1) > 2 ) return true;
					if( this.board.countMatchingPieces(playerIndex, x, y, -1, 1) > 2 ) return true;						
				}
			}				
		}
		this.writeStatus('game not over for ' + this.players[this.currentPlayerIndex].getId(), false, this.LoggingLevelEnum.DEBUG);
	},

	addPlayer : function(isAI) {

		if (this.gameStatus != this.GameStatusEnum.INITIALIZED) {
			return;
		}

		if (this.players.length < this.REQUIRED_PLAYERS) {
			var playerIdentifier =  this.players.length == 0 ? "Red Player" : "Blue Player";   // 'Player ' + (this.players.length+1);
			var player = this.Player.create(playerIdentifier, isAI);
			this.players.push(player);			
			this.view.drawPlayerList(this.players);
			this.writeStatus('player ' + player.getId() + ' added', false, this.LoggingLevelEnum.DEBUG);
		}
	},

	toggleTrace : function(traceOn) {
		this.loggingLevel = traceOn ? this.LoggingLevelEnum.DEBUG : this.LoggingLevelEnum.INFO;
	},

	writeStatus : function(status, replace, level) {
		if (this.loggingLevel.value >= level.value) {
			this.view.writeStatus(status, replace);
		}
	},

	export : function() {
		exports.initialize = this.extensions.bind(this.initialize, this);
	}

};

Game.export();